# Malloc：动态存储分配器

> 英文说明请参考：CMU CS:APP Malloc Lab
>
> 如有任何问题或翻译错误请联系助教

## 1. 简介

在本作业中，你将为 C 语言程序编写一个动态存储分配器（Dynamic Storage Allocator），也就是属于你自己的 `malloc, free, realloc, calloc` 函数。我们鼓励你进行创造性的探索并实现一个正确、高效且快速的分配器。

## 2. 如何上手本作业

你的动态存储分配器将由以下函数组成，这些函数在 `mm.h` 中声明，在 `mm.c` 中定义：

```C
int mm_init(void);
void *malloc(size_t size);
void free(void *ptr);
void *realloc(void *ptr, size_t size);
void *calloc (size_t nmemb, size_t size);
void mm_checkheap(void);
```

我们已正确地实现了给你的 `mm.c` 文件，但很简陋。
因为我们是在 64 位机器上运行的，你的分配器必须依照对应的架构编写，但有一个例外：堆的大小将永远不会大于或等于 $2^{32}$ 字节。这*完全不*影响堆的位置，但有一个巧妙的优化依赖于这个事实。然而，请注意如果你决定利用这一事实，请非常、非常小心。有一些无效的优化会通过所有的驱动检查，因为我们能在合理的时间内检查的功能的范围有限，所以我们将人工查看你的代码是否有这些违规行为。
你可以以 `mm.c`, `mm-naive.c` 或书中的示例代码作为你自己的 `mm.c` 文件的着手点。实现这些函数（可能还要定义其他的私有静态辅助函数）并满足以下要求：

- `mm_init`：执行任何必要的初始化，例如分配初始堆区。如果在执行初始化过程中出现问题，返回值为 -1，否则为 0。**不要在这个函数中调用 `mem_init`！**
  每当驱动程序执行一个新的跟踪，会通过调用你的 `mm_init` 将堆重置为空堆。

- `malloc`：`malloc` 例程返回一个指向已分配的 block payload 的指针，其长度至少为 `size` 字节。整个被分配的块应该位于堆区内，并且不应该与任何其他被分配的块重叠。
  由于标准 C 库（libc）的 `malloc` 总是返回 8 字节对齐的 payload 指针，你的 `malloc` 实现也应如此，返回 8 字节对齐的指针。

- `free`：`free` 例程释放了 `ptr` 指向的块，无返回值。仅当传递的指针（`ptr`）是先前调用 `malloc`、`calloc` 或 `realloc` 的返回值，且还没有被释放时，这个例程才 work。`free(NULL)` 是无效的。

- `realloc`：`realloc` 例程返回一个指向长度至少为 `size` 字节的已分配区域的指针，并有以下限制：

  - 如果 `ptr` 为 `NULL`，该调用等价于 `malloc(size)；`
  - 如果 `size` 为 0，该调用等价于 `free(ptr)` 且返回值应为 `NULL`；
  - 如果 `ptr` 非 `NULL`，它一定是先前调用 `malloc` 或 `realloc` 的返回值且尚未被释放。调用 `realloc` 会获取一个现有的内存块，即 `ptr` 指向的旧块。然后分配一个足够大的内存区域容纳 `size` 字节，并返回这个新块的地址。注意，新块的地址可能与旧块相同（或许旧块后面有空闲的空间可以扩展，或者新的 `size` 小于旧的）；也可以不同，取决于你的实现方式、旧块中的内部碎片数量、以及 `realloc` 请求的大小。如果对 `realloc` 的调用没有失败，并且返回的地址与传入的地址不同，那么旧块已经被释放， 并且不应该被使用、释放或再次传入 `realloc`。
    新区块的内容与旧块（`ptr`）相同，取决于在新旧块中更小的那个，而其他部分是未初始化的。例如，如果旧块是 8 字节，新块是 12 字节，那么新块的前 8 个字节与旧块的前 8 个字节相同，后 4 个字节未初始化。

- `calloc`：为一个 `nmemb` 个 `size` 大小的元素的数组分配内存，并返回一个指针指向分配的内存。这片内存在返回前应被置零。

  **注意：你的 `calloc` 不会在吞吐量或性能方面被评分。一个正确且简洁的实现即可。**

- `mm_checkheap`：该函数扫描并检查堆的一致性。这个函数在你调试 `malloc` 实现时会十分有用。有些 `malloc` 的 bug 很难用传统的 `gdb` 技术进行调试。针对这些 bug 的唯一高效的方法是使用堆一致性检查器。当你遇到 bug 时，你可以通过反复调用一致性检查器来定位 bug，直到你找到破坏你的堆的指令。由于一致性检查器的重要性，它会被纳入评分。如果你向助教寻求帮助，我们要做的第一件事就是检查你的 checkheap 函数，所以请在来找我们之前写好这个函数。

这些要求与对应的 `libc` 例程的语义一致（注意 `mm_checkheap` 在 `libc` 中没有对应的函数）。在 shell 中输入 `man malloc` 可以阅读完整的文档。

## 3. 辅助例程

`memlib.c` 包为你的动态内存分配器模拟了内存系统。你可以调用以下  `memlib.c`  中的函数：

- `void *mem_sbrk(int incr)`：将堆增大 `incr` 字节，其中 `incr` 是一个非零的正整数，并返回一个通用指针指向新分配的堆区域的首个字节。该语义同 Unix 的 `sbrk` 函数，区别是 `mem_sbrk` 仅接受非零正整数。
- `void *mem_heap_lo(void)`：返回一个指向堆中第一个字节的通用指针。
- `void *mem_heap_hi(void)`：返回一个指向堆中最后一个字节的通用指针。
- `size_t mem_heapsize(void)`：返回当前堆的大小，单位字节。
- `size_t mem_pagesize(void)`：返回系统页大小，单位字节（Linux 系统下为 4K）。  

## 4. 评测说明

下发的 `malloclab-handout.tar` 中的评测程序 `mdriver.c` 用于测试你的 `mm.c` 包的正确性、空间利用率和吞吐量。评测程序由一系列 `alloclab-handout.tar` 中的评测数据控制。每个评测数据文件都表示一个 `allocate` 和 `free` 指令的序列，指示评测程序按顺序调用你的 `malloc` 和 `free` 例程。最终评测用的评测程序和数据与下发内容相同。
当评测程序运行时，它将重复执行每个测试数据文件 12 次：一次用于保证你的实现的正确性，一次用于确定空间利用率，还有 10 次是用于确定性能。
评测程序 `mdriver.c` 接受以下命令行参数。正常情况下，运行时不需要任何参数，但你可能会发现在开发过程中使用这些参数很有用。

- `-t <tracedir>`：在 `tracedir` 目录中查找默认的评测数据，而非在 `config.h` 中定义的默认目录查找。
- `-f <tracefile>`：使用一个特定的 `tracefile` 而不是默认的评测数据集来测试正确性和性能。
- `-c <tracefile>`：评测一次指定的评测数据，仅测试正确性。如果你想打印出调试信息，这个选项会非常有用的。
- `-h`：输出命令行参数的说明。
- `-l`：除了学生的 malloc 包，也可以运行和测量 libc malloc。这主要是为了了解 libc malloc 包的速度有多慢。
- `-V`：详细输出。在评测每个评测数据时打印额外的诊断信息。可以用于明确在哪个数据点挂掉了，在调试过程中很有用。
- `-v <verbose level>`：该可选的功能可让你手动设置你的 verbose 级别为特定整数。
- `-d <i>`：在调试等级 0，很少进行有效性检查。如果你已经完成了大部分工作，只是在调整
  性能，那么这很有用。
  在调试等级 1，评测程序申请的每一个数组都是由随机比特填充的。当数组被释放或重新分配
  的时候，我们会检查这些随机比特没有被变化。该等级为默认等级。
  在调试等级 2，每次做任何操作时，都会检查所有的数组。尽管运行速度很慢，但对快速发现问题很有
  用。
- `-D`：等价于 `-d2`。
- `-s <s>`：在 `s` 秒后超时。默认情况是永远不超时。

## 5. 实现要求

- 你不应该改变 `mm.h` 中的任何接口。然而，我们强烈鼓励你在 `mm.c` 中使用静态辅助函数将你的代码分解成小的、易于理解的部分。
- 你不应该使用任何外部内存管理相关库调用或系统调用。严格禁止使用 `libc` 的 `malloc`、`calloc`、`free`、`realloc`、`sbrk`、`brk` 或任何其他内存管理包。
- 你不能在你的 `mm.c` 程序中定义任何全局数据结构，如数组、结构体、树或是链表。然而，你*可以*在 `mm.c` 中声明全局标量变量，如整数、浮点数和指针。
  这种限制的原因是，驱动程序在衡量内存利用率时不能考虑到这种全局变量。如果你需要大型数据结构的空间，你可以把它们放在堆的开头。
- 你不能简单地提交 CS:APP 或 K&R 书中的分配器代码。如果你这样做，你将不会得到任何分数。
  然而，我们鼓励你研究这些例子，并将其作为起点。例如，你可以修改 CS:APP 的代码，使用带有常数时间合并的显式链表。或者你可以修改 K&R 的代码来使用常数时间合并。或者你可以使用其中任何一种作为离散空闲链表分配器的基础。然而请记住，你的分配器必须适用于 64 位机器。
- 看一下教科书或任何其他来源的算法描述是允许的，但不能复制网上或其他来源的 `malloc` 实现的任何代码，除了你的书或 K&R 中描述的隐式空闲链表分配器。
- 我们鼓励你研究评测数据并对其进行优化，但你的代码必须在每个评测数据上都是正确的。你得到的分数是所有标记为 `*` 的评测点的平均分。有的测试数据的利用率得分的权重都相同，而性能得分的权重根据操作数量衡量。换句话说，如果你担心的是速度，那就对最大的测试数据进行优化。
- 为了与 `libc malloc` 包保持一致，该包返回的块以 8 字节对齐，你的分配器必须总是返回以 8 字节对齐的指针。评测程序将检查这一要求。
- 你的代码*必须*消除所有编译警告。警告往往表示你代码中的细微错误；当你有一个警告时，你应该仔细检查相应的代码，看看代码是否真的符合预期。如果是，你应该通过调整代码来消除这个警告（例如，一种常见的警告类型可以通过添加类型转换来消除，当一个值被从一种类型的指针转换到另一种类型）。我们在 Makefile 中添加了标志，以强制你的代码为 error-free。你可以在开发过程中删除这些标志，但请意识到我们会在这些标志激活的情况下对你的代码进行评分。

## 6. 评分

最终提交的评分将基于你的分配器在给定测试数据上的表现，你的堆检查器的质量，以及你的代码风格。下文将对最终提交进行详细要求。
这是一个特殊的大作业，因为我们并不期望你能得到满分。在 `malloc` 上获得 95% 的分数已经是非常了不起的，如果你能做到这一点，你应该感到非常自豪。
总分为 120 分。你将获得*零分*，如果你违反了任何规则，或者你的代码存在 bug 并导致评测程序崩溃。*请确保你已经阅读了上述所有的规则。*你的成绩将被计算如下：
*性能（100 分）*。将用两个指标来评估你的解决方案：

- 空间利用率：评测程序利用的内存总量（即通过 `malloc` 分配但尚未通过 `free` 释放的内存）与分配器使用的堆的大小的最大比例。最高比例为 1。你应该找到好的策略来最小化碎片，以尽可能优化这个比例。
- 吞吐量：平均每秒完成的操作数。

评测程序通过计算*性能指标* $0\leq P\leq 100$ 来总结你的分配器的性能，其综合了空间利用率和吞吐量。
$$
P=100*(w\min(1,\frac{U-U_{min}}{U_{max}-U{min}})+(1-w)\min(1,\frac{T-T_{min}}{T_{max}-T_{min}}))
$$
其中 $U$ 是你的空间利用率， $T$ 是你的吞吐量，$U_{max}$ 和 $T_{max}$ 是一个理想的 `malloc` 包的预计空间利用率和吞吐量，$U_{min}$ 和 $T_{min}$ 是最低的空间利用率和吞吐量，低于这个值你将得到 0 分。性能指数更注重空间利用率而非吞吐量：$w = 0.63$。

> $U_{min}$、$U_{max}$、$T_{min}$ 和 $T_{max}$ 的值是驱动器中的常数（0.6、 0.93、 0 Kops/s 和 25,000 Kops/s），是助教在出题面时确定的。这意味着，一旦你达到 93% 的利用率和 25,000 Kops/s，你的性能指数就完美了。

考虑到内存和 CPU 周期都是昂贵的系统资源，我们采用这个公式来平衡优化内存利用率和吞吐量。由于每个指标对性能指数的贡献最多只有 $w$ 和 $1-w$，所以你不应该极端地仅优化内存利用率或仅优化吞吐量。要得到一个好的分数，你必须在以下方面达到平衡。
100 个性能点（`$perfpoints`）将作为性能指数（`$perfindex`）的一个函数被分配：

```
if ($perfindex < 60) {
	$perfpoints = 0;
}
elsif ($perfindex < 100) {
	$perfpoints = (25 + ((3 * $perfindex) / 4));
}
else {
	$perfpoints = 100;
}
```

如果分配器在任何测试数据中失败或性能指标低于 60，您将不会得到任何性能点。
*堆一致性检查器（10分）*。这 10 分将根据 `mm_checkheap` 的实现质量来评分。你可以自由决定如何实现你的堆检查器。检查器的功能越多，它作为调试工具的价值就越大。
然而，为了获得这部分的全部学分，我们要求你的堆检查器的头注释列出你的数据结构的*所有*常量。对于每一个常量，你应该说明你的堆检查器是否验证了它被满足。 (列举所有的常量而不检查其中的任何一个是不行的；你至少应该验证关键部分。 )下面提供了一些你的堆检查器应该检查的例子：

- 检查堆（隐式链表、显式链表、离散链表）：
  - 检查 epilogue and prologue blocks。
  - 检查块的地址排列。
  - 检查堆的边界。
  - 检查每个区块的 header 和 footer：尺寸（最小尺寸，对齐），上一个/下一个分配/释放位的
    一致性，header 和 footer 相互匹配。  
  - 检查合并：堆中没有两个连续的空闲块。
- 检查空闲链表（显性链表、离散链表）：
  - 所有的后继/前驱指针是一致的（如果 A 的后继指针指向 B， B 的前驱指针应该指向 A）。
  - 所有的空闲链表指针都指向 `mem_heap_lo()` 和 `mem_heap_high()` 之间。
  - 通过迭代每个区块并通过指针遍历空闲链表来计算空闲区块，看它们是否匹配。
  - 每个链表桶中的所有块都落在桶的大小范围内（离散链表）。

*代码风格（10 分）*

- 你的代码应该被分解成函数，并尽可能少地使用全局变量。你应该使用宏或内联函数，将指针运算隔离到尽可能少的地方。
- 你的代码必须以一个头注释开始，概括你的空闲和已分配块的结构，空闲链表的设计，以及你的分配器如何操作空闲列表。
- 除了这个概括性的头注释外，每个函数前都应该有一个头注释，描述函数的作用。

## 9. Hints

- *使用调试器*，帮助你定位内存越界访问。当使用调试器时记得在 Makefile 中设定 -g 标记而非 -O2
- *使用 profiler*，例如 `gprof` 工具会有助于优化性能
- *尽早动工！* 

## 8. More Hints

- Data structures to organize free blocks:
  - Implicit free list
  - Explicit free list
  - Segregated free lists
- Algorithms to scan free blocks:
  - First fit/next fit
  - Blocks sorted by address with first fit
  - Best fit  

In general, we suggest that you start with an implicit free list, then change this to an explicit list, and then
use the explicit list as the basis for a final version based on segregated lists.

- *To Be Continued*